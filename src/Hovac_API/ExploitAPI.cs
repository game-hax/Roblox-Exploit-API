using System;
using System.Linq;
using System.Text;
using Newtonsoft.Json.Linq;
using System.Net;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;

namespace Hovac_API
{
    public class ExploitAPI
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr OpenProcess(uint access, bool inhert_handle, int pid);

        private static WebClient webClient = new WebClient();
        private static JObject GetLatestData()
        {
            return JObject.Parse(webClient.DownloadString("https://cdn.wearedevs.net/software/jjsploit/latestdata.txt"));
        }

        #region Injection & Execution

        public bool IsUpdated()
        {
            JObject latestData = GetLatestData();
            if (!latestData.HasValues)
            {
                MessageBox.Show("Could not check for the latest version. Did your firewall block us?", "Error");
                return false;
            }
            return !(bool)latestData["dll"]["patched"];
        }

        public bool LaunchExploit()
        {
            if (Bootstrap())
            {
                MessageBox.Show("Downloaded Hovac_API.dll update. Updates will load when you next restart this exploit.", "Update Downloaded - Reload Requested");
                return false;
            }
            if (!IsUpdated())
            {
                MessageBox.Show("Exploit is currently patched... Please wait for the developers to fix it!", "Error");
                return false;
            }
            switch (BasicInject.inject_custom())
            {
                case BasicInject.Result.DLLNotFound:
                    MessageBox.Show("A dependency is missing even after being redownloaded. Please be sure your anti-virus is disabled then restart the exploit.", "Error");
                    break;
                case BasicInject.Result.OpenProcFail:
                    MessageBox.Show("An error has occured relating to OpenProc. Please be sure your anti-virus is disabled then restart the exploit.", "Error");
                    break;
                case BasicInject.Result.AllocFail:
                    MessageBox.Show("An error has occured relating to Alloc. Please be sure your anti-virus is disabled then restart the exploit.", "Error");
                    break;
                case BasicInject.Result.LoadLibFail:
                    MessageBox.Show("An error has occured relating to LoadLib. Please be sure your anti-virus is disabled then restart the exploit.", "Error");
                    break;
                case BasicInject.Result.AlreadyInjected:
                    return true;
                case BasicInject.Result.ProcNotOpen:
                    MessageBox.Show("Failed to find Roblox process. Make sure you are using the UWP version of Roblox from the Microsoft Store.", "Error");
                    break;
                case BasicInject.Result.Unknown:
                    MessageBox.Show("An unknown error has occured. Please be sure yout anti-virus is disabled then restart the exploit.", "Error");
                    break;
                default:
                    return true;
            }
            return false;
        }

        public static bool isAPIAttached()
        {
            BasicInject.phandle = OpenProcess(1082U, false, BasicInject.pid);
            return BasicInject.is_injected(BasicInject.phandle, BasicInject.pid, BasicInject.dll_path);
        }

        public void SendLuaScript(string Script)
        {
            BasicInject.phandle = OpenProcess(1082U, false, BasicInject.pid);
            if (BasicInject.pid == 0)
            {
                MessageBox.Show("Error occured. Did the dll properly inject?", "Oops", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
            if (Script == string.Empty)
            {
                return;
            }
            BasicInject.run_script(BasicInject.phandle, BasicInject.pid, BasicInject.dll_path, Script);
        }

        #endregion

        #region Auto Updater

        private void DownloadLatestVersion()
        {
            JObject latestData = GetLatestData();
            if (File.Exists("Module.dll"))
            {
                File.Delete("Module.dll");
            }
            if (File.Exists("Fluxteam_net_API.dll"))
            {
                File.Delete("Fluxteam_net_API.dll");
            }
            if (File.Exists("qdRFzx.exe"))
            {
                File.Delete("qdRFzx.exe");
            }
            webClient.DownloadFile((string)latestData["ui"]["qdRFzx_exe"], "qdRFzx.exe");
            webClient.DownloadFile((string)latestData["ui"]["injDep"], "Fluxteam_net_API.dll");
            webClient.DownloadFile((string)latestData["dll"]["downloadurl"], "Module.dll");
        }

        private bool Bootstrap()
        {
            JObject latestData = GetLatestData();
            try
            {
                if (!File.Exists("VERSION"))
                {
                    DownloadLatestVersion();
                    using (FileStream fs = File.Create("VERSION"))
                    {
                        byte[] info = new UTF8Encoding(true).GetBytes((string)latestData["dll"]["version"]);
                        fs.Write(info, 0, info.Length);
                    }
                }
                else
                {
                    if (int.Parse(File.ReadLines("VERSION").First()) != (int)latestData["dll"]["version"])
                    {
                        DownloadLatestVersion();
                        if (File.Exists("VERSION"))
                            File.Delete("VERSION");
                        using (FileStream fs = File.Create("VERSION"))
                        {
                            byte[] info = new UTF8Encoding(true).GetBytes((string)latestData["dll"]["version"]);
                            fs.Write(info, 0, info.Length);
                        }
                    }
                }
            }
            catch
            {
                MessageBox.Show("Could not download the latest version! Did your firewall block us?", "Error");
            }
            BasicInject.create_files(Path.GetFullPath("Module.dll"));
            return false;
        }

        #endregion

        // I did not write the BasicInject class, I stole it.
        #region Injection & Execution

        private class BasicInject {
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr OpenProcess(uint access, bool inhert_handle, int pid);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern int WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, IntPtr nSize, int lpNumberOfBytesWritten);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetModuleHandle(string lpModuleName);

            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttribute, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

            [DllImport("fluxteam_net_api.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern bool run_script(IntPtr proc, int pid, string path, [MarshalAs(UnmanagedType.LPWStr)] string script);

            [DllImport("fluxteam_net_api.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern bool is_injected(IntPtr proc, int pid, string path);

            [DllImport("fluxteam_net_api.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern bool inject_dll(int pid, [MarshalAs(UnmanagedType.LPWStr)] string script);

            private static BasicInject.Result r_inject(string dll_path)
            {
                FileInfo fileInfo = new FileInfo(dll_path);
                FileSecurity accessControl = fileInfo.GetAccessControl();
                SecurityIdentifier identity = new SecurityIdentifier("S-1-15-2-1");
                accessControl.AddAccessRule(new FileSystemAccessRule(identity, FileSystemRights.FullControl, InheritanceFlags.None, PropagationFlags.NoPropagateInherit, AccessControlType.Allow));
                fileInfo.SetAccessControl(accessControl);
                Process[] processesByName = Process.GetProcessesByName("Windows10Universal");
                if (processesByName.Length == 0)
                {
                    return BasicInject.Result.ProcNotOpen;
                }
                uint num = 0U;
                while ((ulong)num < (ulong)((long)processesByName.Length))
                {
                    Process process = processesByName[(int)num];
                    if (BasicInject.pid != process.Id)
                    {
                        IntPtr intPtr = BasicInject.OpenProcess(1082U, false, process.Id);
                        if (intPtr == BasicInject.NULL)
                        {
                            return BasicInject.Result.OpenProcFail;
                        }
                        IntPtr intPtr2 = BasicInject.VirtualAllocEx(intPtr, BasicInject.NULL, (IntPtr)((dll_path.Length + 1) * Marshal.SizeOf(typeof(char))), 12288U, 64U);
                        if (intPtr2 == BasicInject.NULL)
                        {
                            return BasicInject.Result.AllocFail;
                        }
                        byte[] bytes = Encoding.Default.GetBytes(dll_path);
                        int num2 = BasicInject.WriteProcessMemory(intPtr, intPtr2, bytes, (IntPtr)((dll_path.Length + 1) * Marshal.SizeOf(typeof(char))), 0);
                        if (num2 == 0 || (long)num2 == 6L)
                        {
                            return BasicInject.Result.Unknown;
                        }
                        if (BasicInject.CreateRemoteThread(intPtr, BasicInject.NULL, BasicInject.NULL, BasicInject.GetProcAddress(BasicInject.GetModuleHandle("kernel32.dll"), "LoadLibraryA"), intPtr2, 0U, BasicInject.NULL) == BasicInject.NULL)
                        {
                            return BasicInject.Result.LoadLibFail;
                        }
                        BasicInject.pid = process.Id;
                        BasicInject.phandle = intPtr;
                        return BasicInject.Result.Success;
                    }
                    else
                    {
                        if (BasicInject.pid == process.Id)
                        {
                            return BasicInject.Result.AlreadyInjected;
                        }
                        num += 1U;
                    }
                }
                return BasicInject.Result.Unknown;
            }
            public static BasicInject.Result inject_custom()
            {
                BasicInject.Result result;
                try
                {
                    if (!File.Exists(BasicInject.dll_path))
                    {
                        result = BasicInject.Result.DLLNotFound;
                    }
                    else
                    {
                        result = BasicInject.r_inject(BasicInject.dll_path);
                    }
                }
                catch
                {
                    result = BasicInject.Result.Unknown;
                }
                return result;
            }

            public static void create_files(string dll_path_)
            {
                if (!File.Exists(dll_path_))
                {
                    MessageBox.Show("Downloaded Hovac_API.dll update. Updates will load when you next restart this exploit.", "Update Downloaded - Reload Requested");
                    Environment.Exit(0);
                }
                BasicInject.dll_path = dll_path_;
                string text = "";
                foreach (string text2 in Directory.GetDirectories(Environment.GetEnvironmentVariable("LocalAppData") + "\\Packages"))
                {
                    if (text2.Contains("OBLOXCORPORATION"))
                    {
                        if (Directory.GetDirectories(text2 + "\\AC").Any((string dir) => dir.Contains("Temp")))
                        {
                            text = text2 + "\\AC";
                        }
                    }
                }
                if (text == "")
                {
                    return;
                }
                try
                {
                    if (Directory.Exists("workspace"))
                    {
                        Directory.Move("workspace", "old_workspace");
                    }
                    if (Directory.Exists("autoexec"))
                    {
                        Directory.Move("autoexec", "old_autoexec");
                    }
                }
                catch
                {
                }
                string text3 = Path.Combine(text, "workspace");
                string text4 = Path.Combine(text, "autoexec");
                if (!Directory.Exists(text3))
                {
                    Directory.CreateDirectory(text3);
                }
                if (!Directory.Exists(text4))
                {
                    Directory.CreateDirectory(text4);
                }
            }
            public static string dll_path;
            public static IntPtr phandle;
            public static int pid = 0;
            private static readonly IntPtr NULL = (IntPtr)0;
            public enum Result : uint
            {
                Success,
                DLLNotFound,
                OpenProcFail,
                AllocFail,
                LoadLibFail,
                AlreadyInjected,
                ProcNotOpen,
                Unknown
            }
            
        }

        #endregion
    }
}
